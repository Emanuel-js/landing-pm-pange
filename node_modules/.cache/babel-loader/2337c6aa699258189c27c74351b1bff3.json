{"ast":null,"code":"import { __extends, __assign } from 'tslib';\nimport * as React from 'react';\nimport { Presence } from './types.js';\nimport { layoutStack } from './utils/stack.js';\nimport { SharedLayoutContext } from '../../context/SharedLayoutContext.js';\nimport { MotionContext } from '../../context/MotionContext/index.js';\nimport { resetRotate } from './utils/rotate.js';\nimport { createBatcher } from './utils/batcher.js';\n/**\r\n * @public\r\n */\n\nvar AnimateSharedLayout =\n/** @class */\nfunction (_super) {\n  __extends(AnimateSharedLayout, _super);\n\n  function AnimateSharedLayout() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /**\r\n     * A list of all the children in the shared layout\r\n     */\n\n\n    _this.children = new Set();\n    /**\r\n     * As animate components with a defined `layoutId` are added/removed to the tree,\r\n     * we store them in order. When one is added, it will animate out from the\r\n     * previous one, and when it's removed, it'll animate to the previous one.\r\n     */\n\n    _this.stacks = new Map();\n    /**\r\n     * Track whether the component has mounted. If it hasn't, the presence of added children\r\n     * are set to Present, whereas if it has they're considered Entering\r\n     */\n\n    _this.hasMounted = false;\n    /**\r\n     * Track whether we already have an update scheduled. If we don't, we'll run snapshots\r\n     * and schedule one.\r\n     */\n\n    _this.updateScheduled = false;\n    /**\r\n     * Tracks whether we already have a render scheduled. If we don't, we'll force one with this.forceRender\r\n     */\n\n    _this.renderScheduled = false;\n    /**\r\n     * The methods provided to all children in the shared layout tree.\r\n     */\n\n    _this.syncContext = __assign(__assign({}, createBatcher()), {\n      syncUpdate: function (force) {\n        return _this.scheduleUpdate(force);\n      },\n      forceUpdate: function () {\n        // By copying syncContext to itself, when this component re-renders it'll also re-render\n        // all children subscribed to the SharedLayout context.\n        _this.syncContext = __assign({}, _this.syncContext);\n\n        _this.scheduleUpdate(true);\n      },\n      register: function (child) {\n        return _this.addChild(child);\n      },\n      remove: function (child) {\n        return _this.removeChild(child);\n      }\n    });\n    return _this;\n  }\n\n  AnimateSharedLayout.prototype.componentDidMount = function () {\n    this.hasMounted = true;\n  };\n\n  AnimateSharedLayout.prototype.componentDidUpdate = function () {\n    this.startLayoutAnimation();\n  };\n\n  AnimateSharedLayout.prototype.shouldComponentUpdate = function () {\n    this.renderScheduled = true;\n    return true;\n  };\n\n  AnimateSharedLayout.prototype.startLayoutAnimation = function () {\n    var _this = this;\n    /**\r\n     * Reset update and render scheduled status\r\n     */\n\n\n    this.renderScheduled = this.updateScheduled = false;\n    var type = this.props.type;\n    /**\r\n     * Update presence metadata based on the latest AnimatePresence status.\r\n     * This is a kind of goofy way of dealing with this, perhaps there's a better model to find.\r\n     */\n\n    this.children.forEach(function (child) {\n      if (!child.isPresent) {\n        child.presence = Presence.Exiting;\n      } else if (child.presence !== Presence.Entering) {\n        child.presence = child.presence === Presence.Exiting ? Presence.Entering : Presence.Present;\n      }\n    });\n    this.updateStacks();\n    /**\r\n     * Create a handler which we can use to flush the children animations\r\n     */\n\n    var handler = {\n      measureLayout: function (child) {\n        return child.updateLayoutMeasurement();\n      },\n      layoutReady: function (child) {\n        if (child.getLayoutId() !== undefined) {\n          var stack = _this.getStack(child);\n\n          stack.animate(child, type === \"crossfade\");\n        } else {\n          child.notifyLayoutReady();\n        }\n      },\n      parent: this.context.visualElement\n    };\n    /**\r\n     * Shared layout animations can be used without the AnimateSharedLayout wrapping component.\r\n     * This requires some co-ordination across components to stop layout thrashing\r\n     * and ensure measurements are taken at the correct time.\r\n     *\r\n     * Here we use that same mechanism of schedule/flush.\r\n     */\n\n    this.children.forEach(function (child) {\n      return _this.syncContext.add(child);\n    });\n    this.syncContext.flush(handler);\n    /**\r\n     * Clear snapshots so subsequent rerenders don't retain memory of outgoing components\r\n     */\n\n    this.stacks.forEach(function (stack) {\n      return stack.clearSnapshot();\n    });\n  };\n\n  AnimateSharedLayout.prototype.updateStacks = function () {\n    this.stacks.forEach(function (stack) {\n      return stack.updateLeadAndFollow();\n    });\n  };\n\n  AnimateSharedLayout.prototype.scheduleUpdate = function (force) {\n    if (force === void 0) {\n      force = false;\n    }\n\n    if (!(force || !this.updateScheduled)) return;\n    /**\r\n     * Flag we've scheduled an update\r\n     */\n\n    this.updateScheduled = true;\n    /**\r\n     * Write: Reset rotation transforms so bounding boxes can be accurately measured.\r\n     */\n\n    this.children.forEach(function (child) {\n      return resetRotate(child);\n    });\n    /**\r\n     * Read: Snapshot children\r\n     */\n\n    this.children.forEach(function (child) {\n      return child.snapshotViewportBox();\n    });\n    /**\r\n     * Every child keeps a local snapshot, but we also want to record\r\n     * snapshots of the visible children as, if they're are being removed\r\n     * in this render, we can still access them.\r\n     *\r\n     * TODO: What would be better here is doing a single loop where we\r\n     * only snapshotViewportBoxes of undefined layoutIds and then one for each stack\r\n     */\n\n    this.stacks.forEach(function (stack) {\n      return stack.updateSnapshot();\n    });\n    /**\r\n     * Force a rerender by setting state if we aren't already going to render.\r\n     */\n\n    if (force || !this.renderScheduled) {\n      this.renderScheduled = true;\n      this.forceUpdate();\n    }\n  };\n\n  AnimateSharedLayout.prototype.addChild = function (child) {\n    this.children.add(child);\n    this.addToStack(child);\n    child.presence = this.hasMounted ? Presence.Entering : Presence.Present;\n  };\n\n  AnimateSharedLayout.prototype.removeChild = function (child) {\n    this.scheduleUpdate();\n    this.children.delete(child);\n    this.removeFromStack(child);\n  };\n\n  AnimateSharedLayout.prototype.addToStack = function (child) {\n    var stack = this.getStack(child);\n    stack === null || stack === void 0 ? void 0 : stack.add(child);\n  };\n\n  AnimateSharedLayout.prototype.removeFromStack = function (child) {\n    var stack = this.getStack(child);\n    stack === null || stack === void 0 ? void 0 : stack.remove(child);\n  };\n  /**\r\n   * Return a stack of animate children based on the provided layoutId.\r\n   * Will create a stack if none currently exists with that layoutId.\r\n   */\n\n\n  AnimateSharedLayout.prototype.getStack = function (child) {\n    var id = child.getLayoutId();\n    if (id === undefined) return; // Create stack if it doesn't already exist\n\n    !this.stacks.has(id) && this.stacks.set(id, layoutStack());\n    return this.stacks.get(id);\n  };\n\n  AnimateSharedLayout.prototype.render = function () {\n    return React.createElement(SharedLayoutContext.Provider, {\n      value: this.syncContext\n    }, this.props.children);\n  };\n\n  AnimateSharedLayout.contextType = MotionContext;\n  return AnimateSharedLayout;\n}(React.Component);\n\nexport { AnimateSharedLayout };","map":{"version":3,"names":["__extends","__assign","React","Presence","layoutStack","SharedLayoutContext","MotionContext","resetRotate","createBatcher","AnimateSharedLayout","_super","_this","apply","arguments","children","Set","stacks","Map","hasMounted","updateScheduled","renderScheduled","syncContext","syncUpdate","force","scheduleUpdate","forceUpdate","register","child","addChild","remove","removeChild","prototype","componentDidMount","componentDidUpdate","startLayoutAnimation","shouldComponentUpdate","type","props","forEach","isPresent","presence","Exiting","Entering","Present","updateStacks","handler","measureLayout","updateLayoutMeasurement","layoutReady","getLayoutId","undefined","stack","getStack","animate","notifyLayoutReady","parent","context","visualElement","add","flush","clearSnapshot","updateLeadAndFollow","snapshotViewportBox","updateSnapshot","addToStack","delete","removeFromStack","id","has","set","get","render","createElement","Provider","value","contextType","Component"],"sources":["E:/Projects/project/project mangement dashbord/landing-pm-pange/node_modules/framer-motion/dist/es/components/AnimateSharedLayout/index.js"],"sourcesContent":["import { __extends, __assign } from 'tslib';\r\nimport * as React from 'react';\r\nimport { Presence } from './types.js';\r\nimport { layoutStack } from './utils/stack.js';\r\nimport { SharedLayoutContext } from '../../context/SharedLayoutContext.js';\r\nimport { MotionContext } from '../../context/MotionContext/index.js';\r\nimport { resetRotate } from './utils/rotate.js';\r\nimport { createBatcher } from './utils/batcher.js';\r\n\r\n/**\r\n * @public\r\n */\r\nvar AnimateSharedLayout = /** @class */ (function (_super) {\r\n    __extends(AnimateSharedLayout, _super);\r\n    function AnimateSharedLayout() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        /**\r\n         * A list of all the children in the shared layout\r\n         */\r\n        _this.children = new Set();\r\n        /**\r\n         * As animate components with a defined `layoutId` are added/removed to the tree,\r\n         * we store them in order. When one is added, it will animate out from the\r\n         * previous one, and when it's removed, it'll animate to the previous one.\r\n         */\r\n        _this.stacks = new Map();\r\n        /**\r\n         * Track whether the component has mounted. If it hasn't, the presence of added children\r\n         * are set to Present, whereas if it has they're considered Entering\r\n         */\r\n        _this.hasMounted = false;\r\n        /**\r\n         * Track whether we already have an update scheduled. If we don't, we'll run snapshots\r\n         * and schedule one.\r\n         */\r\n        _this.updateScheduled = false;\r\n        /**\r\n         * Tracks whether we already have a render scheduled. If we don't, we'll force one with this.forceRender\r\n         */\r\n        _this.renderScheduled = false;\r\n        /**\r\n         * The methods provided to all children in the shared layout tree.\r\n         */\r\n        _this.syncContext = __assign(__assign({}, createBatcher()), { syncUpdate: function (force) { return _this.scheduleUpdate(force); }, forceUpdate: function () {\r\n                // By copying syncContext to itself, when this component re-renders it'll also re-render\r\n                // all children subscribed to the SharedLayout context.\r\n                _this.syncContext = __assign({}, _this.syncContext);\r\n                _this.scheduleUpdate(true);\r\n            }, register: function (child) { return _this.addChild(child); }, remove: function (child) { return _this.removeChild(child); } });\r\n        return _this;\r\n    }\r\n    AnimateSharedLayout.prototype.componentDidMount = function () {\r\n        this.hasMounted = true;\r\n    };\r\n    AnimateSharedLayout.prototype.componentDidUpdate = function () {\r\n        this.startLayoutAnimation();\r\n    };\r\n    AnimateSharedLayout.prototype.shouldComponentUpdate = function () {\r\n        this.renderScheduled = true;\r\n        return true;\r\n    };\r\n    AnimateSharedLayout.prototype.startLayoutAnimation = function () {\r\n        var _this = this;\r\n        /**\r\n         * Reset update and render scheduled status\r\n         */\r\n        this.renderScheduled = this.updateScheduled = false;\r\n        var type = this.props.type;\r\n        /**\r\n         * Update presence metadata based on the latest AnimatePresence status.\r\n         * This is a kind of goofy way of dealing with this, perhaps there's a better model to find.\r\n         */\r\n        this.children.forEach(function (child) {\r\n            if (!child.isPresent) {\r\n                child.presence = Presence.Exiting;\r\n            }\r\n            else if (child.presence !== Presence.Entering) {\r\n                child.presence =\r\n                    child.presence === Presence.Exiting\r\n                        ? Presence.Entering\r\n                        : Presence.Present;\r\n            }\r\n        });\r\n        this.updateStacks();\r\n        /**\r\n         * Create a handler which we can use to flush the children animations\r\n         */\r\n        var handler = {\r\n            measureLayout: function (child) { return child.updateLayoutMeasurement(); },\r\n            layoutReady: function (child) {\r\n                if (child.getLayoutId() !== undefined) {\r\n                    var stack = _this.getStack(child);\r\n                    stack.animate(child, type === \"crossfade\");\r\n                }\r\n                else {\r\n                    child.notifyLayoutReady();\r\n                }\r\n            },\r\n            parent: this.context.visualElement,\r\n        };\r\n        /**\r\n         * Shared layout animations can be used without the AnimateSharedLayout wrapping component.\r\n         * This requires some co-ordination across components to stop layout thrashing\r\n         * and ensure measurements are taken at the correct time.\r\n         *\r\n         * Here we use that same mechanism of schedule/flush.\r\n         */\r\n        this.children.forEach(function (child) { return _this.syncContext.add(child); });\r\n        this.syncContext.flush(handler);\r\n        /**\r\n         * Clear snapshots so subsequent rerenders don't retain memory of outgoing components\r\n         */\r\n        this.stacks.forEach(function (stack) { return stack.clearSnapshot(); });\r\n    };\r\n    AnimateSharedLayout.prototype.updateStacks = function () {\r\n        this.stacks.forEach(function (stack) { return stack.updateLeadAndFollow(); });\r\n    };\r\n    AnimateSharedLayout.prototype.scheduleUpdate = function (force) {\r\n        if (force === void 0) { force = false; }\r\n        if (!(force || !this.updateScheduled))\r\n            return;\r\n        /**\r\n         * Flag we've scheduled an update\r\n         */\r\n        this.updateScheduled = true;\r\n        /**\r\n         * Write: Reset rotation transforms so bounding boxes can be accurately measured.\r\n         */\r\n        this.children.forEach(function (child) { return resetRotate(child); });\r\n        /**\r\n         * Read: Snapshot children\r\n         */\r\n        this.children.forEach(function (child) { return child.snapshotViewportBox(); });\r\n        /**\r\n         * Every child keeps a local snapshot, but we also want to record\r\n         * snapshots of the visible children as, if they're are being removed\r\n         * in this render, we can still access them.\r\n         *\r\n         * TODO: What would be better here is doing a single loop where we\r\n         * only snapshotViewportBoxes of undefined layoutIds and then one for each stack\r\n         */\r\n        this.stacks.forEach(function (stack) { return stack.updateSnapshot(); });\r\n        /**\r\n         * Force a rerender by setting state if we aren't already going to render.\r\n         */\r\n        if (force || !this.renderScheduled) {\r\n            this.renderScheduled = true;\r\n            this.forceUpdate();\r\n        }\r\n    };\r\n    AnimateSharedLayout.prototype.addChild = function (child) {\r\n        this.children.add(child);\r\n        this.addToStack(child);\r\n        child.presence = this.hasMounted ? Presence.Entering : Presence.Present;\r\n    };\r\n    AnimateSharedLayout.prototype.removeChild = function (child) {\r\n        this.scheduleUpdate();\r\n        this.children.delete(child);\r\n        this.removeFromStack(child);\r\n    };\r\n    AnimateSharedLayout.prototype.addToStack = function (child) {\r\n        var stack = this.getStack(child);\r\n        stack === null || stack === void 0 ? void 0 : stack.add(child);\r\n    };\r\n    AnimateSharedLayout.prototype.removeFromStack = function (child) {\r\n        var stack = this.getStack(child);\r\n        stack === null || stack === void 0 ? void 0 : stack.remove(child);\r\n    };\r\n    /**\r\n     * Return a stack of animate children based on the provided layoutId.\r\n     * Will create a stack if none currently exists with that layoutId.\r\n     */\r\n    AnimateSharedLayout.prototype.getStack = function (child) {\r\n        var id = child.getLayoutId();\r\n        if (id === undefined)\r\n            return;\r\n        // Create stack if it doesn't already exist\r\n        !this.stacks.has(id) && this.stacks.set(id, layoutStack());\r\n        return this.stacks.get(id);\r\n    };\r\n    AnimateSharedLayout.prototype.render = function () {\r\n        return (React.createElement(SharedLayoutContext.Provider, { value: this.syncContext }, this.props.children));\r\n    };\r\n    AnimateSharedLayout.contextType = MotionContext;\r\n    return AnimateSharedLayout;\r\n}(React.Component));\r\n\r\nexport { AnimateSharedLayout };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}