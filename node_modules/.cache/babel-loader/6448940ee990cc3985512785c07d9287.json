{"ast":null,"code":"import { mix, distance, clamp, progress } from 'popmotion';\n\nvar clampProgress = function (v) {\n  return clamp(0, 1, v);\n};\n/**\r\n * Returns true if the provided value is within maxDistance of the provided target\r\n */\n\n\nfunction isNear(value, target, maxDistance) {\n  if (target === void 0) {\n    target = 0;\n  }\n\n  if (maxDistance === void 0) {\n    maxDistance = 0.01;\n  }\n\n  return distance(value, target) < maxDistance;\n}\n\nfunction calcLength(axis) {\n  return axis.max - axis.min;\n}\n/**\r\n * Calculate a transform origin relative to the source axis, between 0-1, that results\r\n * in an asthetically pleasing scale/transform needed to project from source to target.\r\n */\n\n\nfunction calcOrigin(source, target) {\n  var origin = 0.5;\n  var sourceLength = calcLength(source);\n  var targetLength = calcLength(target);\n\n  if (targetLength > sourceLength) {\n    origin = progress(target.min, target.max - sourceLength, source.min);\n  } else if (sourceLength > targetLength) {\n    origin = progress(source.min, source.max - targetLength, target.min);\n  }\n\n  return clampProgress(origin);\n}\n/**\r\n * Update the AxisDelta with a transform that projects source into target.\r\n *\r\n * The transform `origin` is optional. If not provided, it'll be automatically\r\n * calculated based on the relative positions of the two bounding boxes.\r\n */\n\n\nfunction updateAxisDelta(delta, source, target, origin) {\n  if (origin === void 0) {\n    origin = 0.5;\n  }\n\n  delta.origin = origin;\n  delta.originPoint = mix(source.min, source.max, delta.origin);\n  delta.scale = calcLength(target) / calcLength(source);\n  if (isNear(delta.scale, 1, 0.0001)) delta.scale = 1;\n  delta.translate = mix(target.min, target.max, delta.origin) - delta.originPoint;\n  if (isNear(delta.translate)) delta.translate = 0;\n}\n/**\r\n * Update the BoxDelta with a transform that projects the source into the target.\r\n *\r\n * The transform `origin` is optional. If not provided, it'll be automatically\r\n * calculated based on the relative positions of the two bounding boxes.\r\n */\n\n\nfunction updateBoxDelta(delta, source, target, origin) {\n  updateAxisDelta(delta.x, source.x, target.x, defaultOrigin(origin.originX));\n  updateAxisDelta(delta.y, source.y, target.y, defaultOrigin(origin.originY));\n}\n/**\r\n * Currently this only accepts numerical origins, measured as 0-1, but could\r\n * accept pixel values by comparing to the target axis.\r\n */\n\n\nfunction defaultOrigin(origin) {\n  return typeof origin === \"number\" ? origin : 0.5;\n}\n\nfunction calcRelativeAxis(target, relative, parent) {\n  target.min = parent.min + relative.min;\n  target.max = target.min + calcLength(relative);\n}\n\nfunction calcRelativeBox(projection, parentProjection) {\n  calcRelativeAxis(projection.target.x, projection.relativeTarget.x, parentProjection.target.x);\n  calcRelativeAxis(projection.target.y, projection.relativeTarget.y, parentProjection.target.y);\n}\n\nexport { calcOrigin, calcRelativeAxis, calcRelativeBox, isNear, updateAxisDelta, updateBoxDelta };","map":{"version":3,"names":["mix","distance","clamp","progress","clampProgress","v","isNear","value","target","maxDistance","calcLength","axis","max","min","calcOrigin","source","origin","sourceLength","targetLength","updateAxisDelta","delta","originPoint","scale","translate","updateBoxDelta","x","defaultOrigin","originX","y","originY","calcRelativeAxis","relative","parent","calcRelativeBox","projection","parentProjection","relativeTarget"],"sources":["E:/Projects/project/project mangement dashbord/landing-pm-pange/node_modules/framer-motion/dist/es/utils/geometry/delta-calc.js"],"sourcesContent":["import { mix, distance, clamp, progress } from 'popmotion';\r\n\r\nvar clampProgress = function (v) { return clamp(0, 1, v); };\r\n/**\r\n * Returns true if the provided value is within maxDistance of the provided target\r\n */\r\nfunction isNear(value, target, maxDistance) {\r\n    if (target === void 0) { target = 0; }\r\n    if (maxDistance === void 0) { maxDistance = 0.01; }\r\n    return distance(value, target) < maxDistance;\r\n}\r\nfunction calcLength(axis) {\r\n    return axis.max - axis.min;\r\n}\r\n/**\r\n * Calculate a transform origin relative to the source axis, between 0-1, that results\r\n * in an asthetically pleasing scale/transform needed to project from source to target.\r\n */\r\nfunction calcOrigin(source, target) {\r\n    var origin = 0.5;\r\n    var sourceLength = calcLength(source);\r\n    var targetLength = calcLength(target);\r\n    if (targetLength > sourceLength) {\r\n        origin = progress(target.min, target.max - sourceLength, source.min);\r\n    }\r\n    else if (sourceLength > targetLength) {\r\n        origin = progress(source.min, source.max - targetLength, target.min);\r\n    }\r\n    return clampProgress(origin);\r\n}\r\n/**\r\n * Update the AxisDelta with a transform that projects source into target.\r\n *\r\n * The transform `origin` is optional. If not provided, it'll be automatically\r\n * calculated based on the relative positions of the two bounding boxes.\r\n */\r\nfunction updateAxisDelta(delta, source, target, origin) {\r\n    if (origin === void 0) { origin = 0.5; }\r\n    delta.origin = origin;\r\n    delta.originPoint = mix(source.min, source.max, delta.origin);\r\n    delta.scale = calcLength(target) / calcLength(source);\r\n    if (isNear(delta.scale, 1, 0.0001))\r\n        delta.scale = 1;\r\n    delta.translate =\r\n        mix(target.min, target.max, delta.origin) - delta.originPoint;\r\n    if (isNear(delta.translate))\r\n        delta.translate = 0;\r\n}\r\n/**\r\n * Update the BoxDelta with a transform that projects the source into the target.\r\n *\r\n * The transform `origin` is optional. If not provided, it'll be automatically\r\n * calculated based on the relative positions of the two bounding boxes.\r\n */\r\nfunction updateBoxDelta(delta, source, target, origin) {\r\n    updateAxisDelta(delta.x, source.x, target.x, defaultOrigin(origin.originX));\r\n    updateAxisDelta(delta.y, source.y, target.y, defaultOrigin(origin.originY));\r\n}\r\n/**\r\n * Currently this only accepts numerical origins, measured as 0-1, but could\r\n * accept pixel values by comparing to the target axis.\r\n */\r\nfunction defaultOrigin(origin) {\r\n    return typeof origin === \"number\" ? origin : 0.5;\r\n}\r\nfunction calcRelativeAxis(target, relative, parent) {\r\n    target.min = parent.min + relative.min;\r\n    target.max = target.min + calcLength(relative);\r\n}\r\nfunction calcRelativeBox(projection, parentProjection) {\r\n    calcRelativeAxis(projection.target.x, projection.relativeTarget.x, parentProjection.target.x);\r\n    calcRelativeAxis(projection.target.y, projection.relativeTarget.y, parentProjection.target.y);\r\n}\r\n\r\nexport { calcOrigin, calcRelativeAxis, calcRelativeBox, isNear, updateAxisDelta, updateBoxDelta };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}