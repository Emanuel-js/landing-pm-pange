{"ast":null,"code":"import { __assign } from 'tslib';\nimport { complex, px } from 'style-value-types';\nimport { mix } from 'popmotion';\nimport { cssVariableRegex } from '../utils/css-variables-conversion.js';\n\nfunction pixelsToPercent(pixels, axis) {\n  return pixels / (axis.max - axis.min) * 100;\n}\n/**\r\n * We always correct borderRadius as a percentage rather than pixels to reduce paints.\r\n * For example, if you are projecting a box that is 100px wide with a 10px borderRadius\r\n * into a box that is 200px wide with a 20px borderRadius, that is actually a 10%\r\n * borderRadius in both states. If we animate between the two in pixels that will trigger\r\n * a paint each time. If we animate between the two in percentage we'll avoid a paint.\r\n */\n\n\nfunction correctBorderRadius(latest, _layoutState, _a) {\n  var target = _a.target;\n  /**\r\n   * If latest is a string, if it's a percentage we can return immediately as it's\r\n   * going to be stretched appropriately. Otherwise, if it's a pixel, convert it to a number.\r\n   */\n\n  if (typeof latest === \"string\") {\n    if (px.test(latest)) {\n      latest = parseFloat(latest);\n    } else {\n      return latest;\n    }\n  }\n  /**\r\n   * If latest is a number, it's a pixel value. We use the current viewportBox to calculate that\r\n   * pixel value as a percentage of each axis\r\n   */\n\n\n  var x = pixelsToPercent(latest, target.x);\n  var y = pixelsToPercent(latest, target.y);\n  return x + \"% \" + y + \"%\";\n}\n\nvar varToken = \"_$css\";\n\nfunction correctBoxShadow(latest, _a) {\n  var delta = _a.delta,\n      treeScale = _a.treeScale;\n  var original = latest;\n  /**\r\n   * We need to first strip and store CSS variables from the string.\r\n   */\n\n  var containsCSSVariables = latest.includes(\"var(\");\n  var cssVariables = [];\n\n  if (containsCSSVariables) {\n    latest = latest.replace(cssVariableRegex, function (match) {\n      cssVariables.push(match);\n      return varToken;\n    });\n  }\n\n  var shadow = complex.parse(latest); // TODO: Doesn't support multiple shadows\n\n  if (shadow.length > 5) return original;\n  var template = complex.createTransformer(latest);\n  var offset = typeof shadow[0] !== \"number\" ? 1 : 0; // Calculate the overall context scale\n\n  var xScale = delta.x.scale * treeScale.x;\n  var yScale = delta.y.scale * treeScale.y;\n  shadow[0 + offset] /= xScale;\n  shadow[1 + offset] /= yScale;\n  /**\r\n   * Ideally we'd correct x and y scales individually, but because blur and\r\n   * spread apply to both we have to take a scale average and apply that instead.\r\n   * We could potentially improve the outcome of this by incorporating the ratio between\r\n   * the two scales.\r\n   */\n\n  var averageScale = mix(xScale, yScale, 0.5); // Blur\n\n  if (typeof shadow[2 + offset] === \"number\") shadow[2 + offset] /= averageScale; // Spread\n\n  if (typeof shadow[3 + offset] === \"number\") shadow[3 + offset] /= averageScale;\n  var output = template(shadow);\n\n  if (containsCSSVariables) {\n    var i_1 = 0;\n    output = output.replace(varToken, function () {\n      var cssVariable = cssVariables[i_1];\n      i_1++;\n      return cssVariable;\n    });\n  }\n\n  return output;\n}\n\nvar borderCorrectionDefinition = {\n  process: correctBorderRadius\n};\nvar defaultScaleCorrectors = {\n  borderRadius: __assign(__assign({}, borderCorrectionDefinition), {\n    applyTo: [\"borderTopLeftRadius\", \"borderTopRightRadius\", \"borderBottomLeftRadius\", \"borderBottomRightRadius\"]\n  }),\n  borderTopLeftRadius: borderCorrectionDefinition,\n  borderTopRightRadius: borderCorrectionDefinition,\n  borderBottomLeftRadius: borderCorrectionDefinition,\n  borderBottomRightRadius: borderCorrectionDefinition,\n  boxShadow: {\n    process: correctBoxShadow\n  }\n};\nexport { correctBorderRadius, correctBoxShadow, defaultScaleCorrectors, pixelsToPercent };","map":{"version":3,"names":["__assign","complex","px","mix","cssVariableRegex","pixelsToPercent","pixels","axis","max","min","correctBorderRadius","latest","_layoutState","_a","target","test","parseFloat","x","y","varToken","correctBoxShadow","delta","treeScale","original","containsCSSVariables","includes","cssVariables","replace","match","push","shadow","parse","length","template","createTransformer","offset","xScale","scale","yScale","averageScale","output","i_1","cssVariable","borderCorrectionDefinition","process","defaultScaleCorrectors","borderRadius","applyTo","borderTopLeftRadius","borderTopRightRadius","borderBottomLeftRadius","borderBottomRightRadius","boxShadow"],"sources":["E:/Projects/project/project mangement dashbord/landing-pm-pange/node_modules/framer-motion/dist/es/render/dom/projection/default-scale-correctors.js"],"sourcesContent":["import { __assign } from 'tslib';\r\nimport { complex, px } from 'style-value-types';\r\nimport { mix } from 'popmotion';\r\nimport { cssVariableRegex } from '../utils/css-variables-conversion.js';\r\n\r\nfunction pixelsToPercent(pixels, axis) {\r\n    return (pixels / (axis.max - axis.min)) * 100;\r\n}\r\n/**\r\n * We always correct borderRadius as a percentage rather than pixels to reduce paints.\r\n * For example, if you are projecting a box that is 100px wide with a 10px borderRadius\r\n * into a box that is 200px wide with a 20px borderRadius, that is actually a 10%\r\n * borderRadius in both states. If we animate between the two in pixels that will trigger\r\n * a paint each time. If we animate between the two in percentage we'll avoid a paint.\r\n */\r\nfunction correctBorderRadius(latest, _layoutState, _a) {\r\n    var target = _a.target;\r\n    /**\r\n     * If latest is a string, if it's a percentage we can return immediately as it's\r\n     * going to be stretched appropriately. Otherwise, if it's a pixel, convert it to a number.\r\n     */\r\n    if (typeof latest === \"string\") {\r\n        if (px.test(latest)) {\r\n            latest = parseFloat(latest);\r\n        }\r\n        else {\r\n            return latest;\r\n        }\r\n    }\r\n    /**\r\n     * If latest is a number, it's a pixel value. We use the current viewportBox to calculate that\r\n     * pixel value as a percentage of each axis\r\n     */\r\n    var x = pixelsToPercent(latest, target.x);\r\n    var y = pixelsToPercent(latest, target.y);\r\n    return x + \"% \" + y + \"%\";\r\n}\r\nvar varToken = \"_$css\";\r\nfunction correctBoxShadow(latest, _a) {\r\n    var delta = _a.delta, treeScale = _a.treeScale;\r\n    var original = latest;\r\n    /**\r\n     * We need to first strip and store CSS variables from the string.\r\n     */\r\n    var containsCSSVariables = latest.includes(\"var(\");\r\n    var cssVariables = [];\r\n    if (containsCSSVariables) {\r\n        latest = latest.replace(cssVariableRegex, function (match) {\r\n            cssVariables.push(match);\r\n            return varToken;\r\n        });\r\n    }\r\n    var shadow = complex.parse(latest);\r\n    // TODO: Doesn't support multiple shadows\r\n    if (shadow.length > 5)\r\n        return original;\r\n    var template = complex.createTransformer(latest);\r\n    var offset = typeof shadow[0] !== \"number\" ? 1 : 0;\r\n    // Calculate the overall context scale\r\n    var xScale = delta.x.scale * treeScale.x;\r\n    var yScale = delta.y.scale * treeScale.y;\r\n    shadow[0 + offset] /= xScale;\r\n    shadow[1 + offset] /= yScale;\r\n    /**\r\n     * Ideally we'd correct x and y scales individually, but because blur and\r\n     * spread apply to both we have to take a scale average and apply that instead.\r\n     * We could potentially improve the outcome of this by incorporating the ratio between\r\n     * the two scales.\r\n     */\r\n    var averageScale = mix(xScale, yScale, 0.5);\r\n    // Blur\r\n    if (typeof shadow[2 + offset] === \"number\")\r\n        shadow[2 + offset] /= averageScale;\r\n    // Spread\r\n    if (typeof shadow[3 + offset] === \"number\")\r\n        shadow[3 + offset] /= averageScale;\r\n    var output = template(shadow);\r\n    if (containsCSSVariables) {\r\n        var i_1 = 0;\r\n        output = output.replace(varToken, function () {\r\n            var cssVariable = cssVariables[i_1];\r\n            i_1++;\r\n            return cssVariable;\r\n        });\r\n    }\r\n    return output;\r\n}\r\nvar borderCorrectionDefinition = {\r\n    process: correctBorderRadius,\r\n};\r\nvar defaultScaleCorrectors = {\r\n    borderRadius: __assign(__assign({}, borderCorrectionDefinition), { applyTo: [\r\n            \"borderTopLeftRadius\",\r\n            \"borderTopRightRadius\",\r\n            \"borderBottomLeftRadius\",\r\n            \"borderBottomRightRadius\",\r\n        ] }),\r\n    borderTopLeftRadius: borderCorrectionDefinition,\r\n    borderTopRightRadius: borderCorrectionDefinition,\r\n    borderBottomLeftRadius: borderCorrectionDefinition,\r\n    borderBottomRightRadius: borderCorrectionDefinition,\r\n    boxShadow: {\r\n        process: correctBoxShadow,\r\n    },\r\n};\r\n\r\nexport { correctBorderRadius, correctBoxShadow, defaultScaleCorrectors, pixelsToPercent };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}