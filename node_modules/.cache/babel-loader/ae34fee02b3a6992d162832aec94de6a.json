{"ast":null,"code":"import sync, { flushSync } from 'framesync';\nimport { compareByDepth } from '../../../render/utils/compare-by-depth.js';\nimport { Presence } from '../types.js';\n/**\r\n * Default handlers for batching VisualElements\r\n */\n\nvar defaultHandler = {\n  measureLayout: function (child) {\n    return child.updateLayoutMeasurement();\n  },\n  layoutReady: function (child) {\n    return child.notifyLayoutReady();\n  }\n};\n/**\r\n * Create a batcher to process VisualElements\r\n */\n\nfunction createBatcher() {\n  var queue = new Set();\n  return {\n    add: function (child) {\n      return queue.add(child);\n    },\n    flush: function (_a) {\n      var _b = _a === void 0 ? defaultHandler : _a,\n          measureLayout = _b.measureLayout,\n          layoutReady = _b.layoutReady,\n          parent = _b.parent;\n\n      var order = Array.from(queue).sort(compareByDepth);\n\n      var resetAndMeasure = function () {\n        /**\r\n         * Write: Reset any transforms on children elements so we can read their actual layout\r\n         */\n        order.forEach(function (child) {\n          return child.resetTransform();\n        });\n        /**\r\n         * Read: Measure the actual layout\r\n         */\n\n        order.forEach(measureLayout);\n      };\n\n      parent ? parent.withoutTransform(resetAndMeasure) : resetAndMeasure();\n      /**\r\n       * Write: Notify the VisualElements they're ready for further write operations.\r\n       */\n\n      order.forEach(layoutReady);\n      /**\r\n       * After all children have started animating, ensure any Entering components are set to Present.\r\n       * If we add deferred animations (set up all animations and then start them in two loops) this\r\n       * could be moved to the start loop. But it needs to happen after all the animations configs\r\n       * are generated in AnimateSharedLayout as this relies on presence data\r\n       */\n\n      order.forEach(function (child) {\n        if (child.isPresent) child.presence = Presence.Present;\n      });\n      /**\r\n       * Starting these animations will have queued jobs on the frame loop. In some situations,\r\n       * like when removing an element, these will be processed too late after the DOM is manipulated,\r\n       * leaving a flash of incorrectly-projected content. By manually flushing these jobs\r\n       * we ensure there's no flash.\r\n       */\n\n      flushSync.preRender();\n      flushSync.render();\n      /**\r\n       * Schedule a callback at the end of the following frame to assign the latest projection\r\n       * box to the prevViewportBox snapshot. Once global batching is in place this could be run\r\n       * synchronously. But for now it ensures that if any nested `AnimateSharedLayout` top-level\r\n       * child attempts to calculate its previous relative position against a prevViewportBox\r\n       * it will be against its latest projection box instead, as the snapshot is useless beyond this\r\n       * render.\r\n       */\n\n      sync.postRender(function () {\n        return order.forEach(assignProjectionToSnapshot);\n      });\n      queue.clear();\n    }\n  };\n}\n\nfunction assignProjectionToSnapshot(child) {\n  child.prevViewportBox = child.projection.target;\n}\n\nexport { createBatcher };","map":{"version":3,"names":["sync","flushSync","compareByDepth","Presence","defaultHandler","measureLayout","child","updateLayoutMeasurement","layoutReady","notifyLayoutReady","createBatcher","queue","Set","add","flush","_a","_b","parent","order","Array","from","sort","resetAndMeasure","forEach","resetTransform","withoutTransform","isPresent","presence","Present","preRender","render","postRender","assignProjectionToSnapshot","clear","prevViewportBox","projection","target"],"sources":["E:/Projects/project/project mangement dashbord/landing-pm-pange/node_modules/framer-motion/dist/es/components/AnimateSharedLayout/utils/batcher.js"],"sourcesContent":["import sync, { flushSync } from 'framesync';\r\nimport { compareByDepth } from '../../../render/utils/compare-by-depth.js';\r\nimport { Presence } from '../types.js';\r\n\r\n/**\r\n * Default handlers for batching VisualElements\r\n */\r\nvar defaultHandler = {\r\n    measureLayout: function (child) { return child.updateLayoutMeasurement(); },\r\n    layoutReady: function (child) { return child.notifyLayoutReady(); },\r\n};\r\n/**\r\n * Create a batcher to process VisualElements\r\n */\r\nfunction createBatcher() {\r\n    var queue = new Set();\r\n    return {\r\n        add: function (child) { return queue.add(child); },\r\n        flush: function (_a) {\r\n            var _b = _a === void 0 ? defaultHandler : _a, measureLayout = _b.measureLayout, layoutReady = _b.layoutReady, parent = _b.parent;\r\n            var order = Array.from(queue).sort(compareByDepth);\r\n            var resetAndMeasure = function () {\r\n                /**\r\n                 * Write: Reset any transforms on children elements so we can read their actual layout\r\n                 */\r\n                order.forEach(function (child) { return child.resetTransform(); });\r\n                /**\r\n                 * Read: Measure the actual layout\r\n                 */\r\n                order.forEach(measureLayout);\r\n            };\r\n            parent\r\n                ? parent.withoutTransform(resetAndMeasure)\r\n                : resetAndMeasure();\r\n            /**\r\n             * Write: Notify the VisualElements they're ready for further write operations.\r\n             */\r\n            order.forEach(layoutReady);\r\n            /**\r\n             * After all children have started animating, ensure any Entering components are set to Present.\r\n             * If we add deferred animations (set up all animations and then start them in two loops) this\r\n             * could be moved to the start loop. But it needs to happen after all the animations configs\r\n             * are generated in AnimateSharedLayout as this relies on presence data\r\n             */\r\n            order.forEach(function (child) {\r\n                if (child.isPresent)\r\n                    child.presence = Presence.Present;\r\n            });\r\n            /**\r\n             * Starting these animations will have queued jobs on the frame loop. In some situations,\r\n             * like when removing an element, these will be processed too late after the DOM is manipulated,\r\n             * leaving a flash of incorrectly-projected content. By manually flushing these jobs\r\n             * we ensure there's no flash.\r\n             */\r\n            flushSync.preRender();\r\n            flushSync.render();\r\n            /**\r\n             * Schedule a callback at the end of the following frame to assign the latest projection\r\n             * box to the prevViewportBox snapshot. Once global batching is in place this could be run\r\n             * synchronously. But for now it ensures that if any nested `AnimateSharedLayout` top-level\r\n             * child attempts to calculate its previous relative position against a prevViewportBox\r\n             * it will be against its latest projection box instead, as the snapshot is useless beyond this\r\n             * render.\r\n             */\r\n            sync.postRender(function () { return order.forEach(assignProjectionToSnapshot); });\r\n            queue.clear();\r\n        },\r\n    };\r\n}\r\nfunction assignProjectionToSnapshot(child) {\r\n    child.prevViewportBox = child.projection.target;\r\n}\r\n\r\nexport { createBatcher };\r\n"],"mappings":"AAAA,OAAOA,IAAP,IAAeC,SAAf,QAAgC,WAAhC;AACA,SAASC,cAAT,QAA+B,2CAA/B;AACA,SAASC,QAAT,QAAyB,aAAzB;AAEA;AACA;AACA;;AACA,IAAIC,cAAc,GAAG;EACjBC,aAAa,EAAE,UAAUC,KAAV,EAAiB;IAAE,OAAOA,KAAK,CAACC,uBAAN,EAAP;EAAyC,CAD1D;EAEjBC,WAAW,EAAE,UAAUF,KAAV,EAAiB;IAAE,OAAOA,KAAK,CAACG,iBAAN,EAAP;EAAmC;AAFlD,CAArB;AAIA;AACA;AACA;;AACA,SAASC,aAAT,GAAyB;EACrB,IAAIC,KAAK,GAAG,IAAIC,GAAJ,EAAZ;EACA,OAAO;IACHC,GAAG,EAAE,UAAUP,KAAV,EAAiB;MAAE,OAAOK,KAAK,CAACE,GAAN,CAAUP,KAAV,CAAP;IAA0B,CAD/C;IAEHQ,KAAK,EAAE,UAAUC,EAAV,EAAc;MACjB,IAAIC,EAAE,GAAGD,EAAE,KAAK,KAAK,CAAZ,GAAgBX,cAAhB,GAAiCW,EAA1C;MAAA,IAA8CV,aAAa,GAAGW,EAAE,CAACX,aAAjE;MAAA,IAAgFG,WAAW,GAAGQ,EAAE,CAACR,WAAjG;MAAA,IAA8GS,MAAM,GAAGD,EAAE,CAACC,MAA1H;;MACA,IAAIC,KAAK,GAAGC,KAAK,CAACC,IAAN,CAAWT,KAAX,EAAkBU,IAAlB,CAAuBnB,cAAvB,CAAZ;;MACA,IAAIoB,eAAe,GAAG,YAAY;QAC9B;AAChB;AACA;QACgBJ,KAAK,CAACK,OAAN,CAAc,UAAUjB,KAAV,EAAiB;UAAE,OAAOA,KAAK,CAACkB,cAAN,EAAP;QAAgC,CAAjE;QACA;AAChB;AACA;;QACgBN,KAAK,CAACK,OAAN,CAAclB,aAAd;MACH,CATD;;MAUAY,MAAM,GACAA,MAAM,CAACQ,gBAAP,CAAwBH,eAAxB,CADA,GAEAA,eAAe,EAFrB;MAGA;AACZ;AACA;;MACYJ,KAAK,CAACK,OAAN,CAAcf,WAAd;MACA;AACZ;AACA;AACA;AACA;AACA;;MACYU,KAAK,CAACK,OAAN,CAAc,UAAUjB,KAAV,EAAiB;QAC3B,IAAIA,KAAK,CAACoB,SAAV,EACIpB,KAAK,CAACqB,QAAN,GAAiBxB,QAAQ,CAACyB,OAA1B;MACP,CAHD;MAIA;AACZ;AACA;AACA;AACA;AACA;;MACY3B,SAAS,CAAC4B,SAAV;MACA5B,SAAS,CAAC6B,MAAV;MACA;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;MACY9B,IAAI,CAAC+B,UAAL,CAAgB,YAAY;QAAE,OAAOb,KAAK,CAACK,OAAN,CAAcS,0BAAd,CAAP;MAAmD,CAAjF;MACArB,KAAK,CAACsB,KAAN;IACH;EAlDE,CAAP;AAoDH;;AACD,SAASD,0BAAT,CAAoC1B,KAApC,EAA2C;EACvCA,KAAK,CAAC4B,eAAN,GAAwB5B,KAAK,CAAC6B,UAAN,CAAiBC,MAAzC;AACH;;AAED,SAAS1B,aAAT"},"metadata":{},"sourceType":"module"}