{"ast":null,"code":"import { __extends, __rest, __assign, __read } from 'tslib';\nimport * as React from 'react';\nimport { eachAxis } from '../../../utils/each-axis.js';\nimport { startAnimation, getValueTransition } from '../../../animation/utils/transitions.js';\nimport { checkIfParentHasChanged, calcRelativeOffset, tweenAxis } from './utils.js';\nimport { VisibilityAction } from '../../../components/AnimateSharedLayout/types.js';\nimport { usePresence } from '../../../components/AnimatePresence/use-presence.js';\nimport { axisBox } from '../../../utils/geometry/index.js';\nimport { addScaleCorrection } from '../../../render/dom/projection/scale-correction.js';\nimport { defaultScaleCorrectors } from '../../../render/dom/projection/default-scale-correctors.js';\nvar progressTarget = 1000;\n\nvar Animate =\n/** @class */\nfunction (_super) {\n  __extends(Animate, _super);\n\n  function Animate() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /**\r\n     * A mutable object that tracks the target viewport box\r\n     * for the current animation frame.\r\n     */\n\n\n    _this.frameTarget = axisBox();\n    /**\r\n     * The current animation target, we use this to check whether to start\r\n     * a new animation or continue the existing one.\r\n     */\n\n    _this.currentAnimationTarget = axisBox();\n    /**\r\n     * Track whether we're animating this axis.\r\n     */\n\n    _this.isAnimating = {\n      x: false,\n      y: false\n    };\n    _this.stopAxisAnimation = {\n      x: undefined,\n      y: undefined\n    };\n    _this.isAnimatingTree = false;\n\n    _this.animate = function (target, origin, _a) {\n      if (_a === void 0) {\n        _a = {};\n      }\n\n      var originBox = _a.originBox,\n          targetBox = _a.targetBox,\n          visibilityAction = _a.visibilityAction,\n          shouldStackAnimate = _a.shouldStackAnimate,\n          onComplete = _a.onComplete,\n          prevParent = _a.prevParent,\n          config = __rest(_a, [\"originBox\", \"targetBox\", \"visibilityAction\", \"shouldStackAnimate\", \"onComplete\", \"prevParent\"]);\n\n      var _b = _this.props,\n          visualElement = _b.visualElement,\n          layout = _b.layout;\n      /**\r\n       * Early return if we've been instructed not to animate this render.\r\n       */\n\n      if (shouldStackAnimate === false) {\n        _this.isAnimatingTree = false;\n        return _this.safeToRemove();\n      }\n      /**\r\n       * Prioritise tree animations\r\n       */\n\n\n      if (_this.isAnimatingTree && shouldStackAnimate !== true) {\n        return;\n      } else if (shouldStackAnimate) {\n        _this.isAnimatingTree = true;\n      }\n      /**\r\n       * Allow the measured origin (prev bounding box) and target (actual layout) to be\r\n       * overridden by the provided config.\r\n       */\n\n\n      origin = originBox || origin;\n      target = targetBox || target;\n      /**\r\n       * If this element has a projecting parent, there's an opportunity to animate\r\n       * it relatively to that parent rather than relatively to the viewport. This\r\n       * allows us to add orchestrated animations.\r\n       */\n\n      var isRelative = false;\n      var projectionParent = visualElement.getProjectionParent();\n\n      if (projectionParent) {\n        var prevParentViewportBox = projectionParent.prevViewportBox;\n        var parentLayout = projectionParent.getLayoutState().layout;\n        /**\r\n         * If we're being provided a previous parent VisualElement by AnimateSharedLayout\r\n         */\n\n        if (prevParent) {\n          /**\r\n           * If we've been provided an explicit target box it means we're animating back\r\n           * to this previous parent. So we can make a relative box by comparing to the previous\r\n           * parent's layout\r\n           */\n          if (targetBox) {\n            parentLayout = prevParent.getLayoutState().layout;\n          }\n          /**\r\n           * Likewise if we've been provided an explicit origin box it means we're\r\n           * animating out from a different element. So we should figure out where that was\r\n           * on screen relative to the new parent element.\r\n           */\n\n\n          if (originBox && !checkIfParentHasChanged(prevParent, projectionParent) && prevParent.prevViewportBox) {\n            prevParentViewportBox = prevParent.prevViewportBox;\n          }\n        }\n\n        if (prevParentViewportBox && isProvidedCorrectDataForRelativeSharedLayout(prevParent, originBox, targetBox)) {\n          isRelative = true;\n          origin = calcRelativeOffset(prevParentViewportBox, origin);\n          target = calcRelativeOffset(parentLayout, target);\n        }\n      }\n\n      var boxHasMoved = hasMoved(origin, target);\n      var animations = eachAxis(function (axis) {\n        /**\r\n         * If layout is set to \"position\", we can resize the origin box based on the target\r\n         * box and only animate its position.\r\n         */\n        if (layout === \"position\") {\n          var targetLength = target[axis].max - target[axis].min;\n          origin[axis].max = origin[axis].min + targetLength;\n        }\n\n        if (visualElement.projection.isTargetLocked) {\n          return;\n        } else if (visibilityAction !== undefined) {\n          visualElement.setVisibility(visibilityAction === VisibilityAction.Show);\n        } else if (boxHasMoved) {\n          // If the box has moved, animate between it's current visual state and its\n          // final state\n          return _this.animateAxis(axis, target[axis], origin[axis], __assign(__assign({}, config), {\n            isRelative: isRelative\n          }));\n        } else {\n          // If the box has remained in the same place, immediately set the axis target\n          // to the final desired state\n          return visualElement.setProjectionTargetAxis(axis, target[axis].min, target[axis].max, isRelative);\n        }\n      }); // Force a render to ensure there's no flash of uncorrected bounding box.\n\n      visualElement.syncRender();\n      /**\r\n       * If this visualElement isn't present (ie it's been removed from the tree by the user but\r\n       * kept in by the tree by AnimatePresence) then call safeToRemove when all axis animations\r\n       * have successfully finished.\r\n       */\n\n      return Promise.all(animations).then(function () {\n        _this.isAnimatingTree = false;\n        onComplete && onComplete();\n        visualElement.notifyLayoutAnimationComplete();\n      });\n    };\n\n    return _this;\n  }\n\n  Animate.prototype.componentDidMount = function () {\n    var _this = this;\n\n    var visualElement = this.props.visualElement;\n    visualElement.animateMotionValue = startAnimation;\n    visualElement.enableLayoutProjection();\n    this.unsubLayoutReady = visualElement.onLayoutUpdate(this.animate);\n\n    visualElement.layoutSafeToRemove = function () {\n      return _this.safeToRemove();\n    };\n\n    addScaleCorrection(defaultScaleCorrectors);\n  };\n\n  Animate.prototype.componentWillUnmount = function () {\n    var _this = this;\n\n    this.unsubLayoutReady();\n    eachAxis(function (axis) {\n      var _a, _b;\n\n      return (_b = (_a = _this.stopAxisAnimation)[axis]) === null || _b === void 0 ? void 0 : _b.call(_a);\n    });\n  };\n  /**\r\n   * TODO: This manually performs animations on the visualElement's layout progress\r\n   * values. It'd be preferable to amend the startLayoutAxisAnimation\r\n   * API to accept more custom animations like this.\r\n   */\n\n\n  Animate.prototype.animateAxis = function (axis, target, origin, _a) {\n    var _this = this;\n\n    var _b, _c;\n\n    var _d = _a === void 0 ? {} : _a,\n        transition = _d.transition,\n        isRelative = _d.isRelative;\n    /**\r\n     * If we're not animating to a new target, don't run this animation\r\n     */\n\n\n    if (this.isAnimating[axis] && axisIsEqual(target, this.currentAnimationTarget[axis])) {\n      return;\n    }\n\n    (_c = (_b = this.stopAxisAnimation)[axis]) === null || _c === void 0 ? void 0 : _c.call(_b);\n    this.isAnimating[axis] = true;\n    var visualElement = this.props.visualElement;\n    var frameTarget = this.frameTarget[axis];\n    var layoutProgress = visualElement.getProjectionAnimationProgress()[axis];\n    /**\r\n     * Set layout progress back to 0. We set it twice to hard-reset any velocity that might\r\n     * be re-incoporated into a subsequent spring animation.\r\n     */\n\n    layoutProgress.clearListeners();\n    layoutProgress.set(0);\n    layoutProgress.set(0);\n    /**\r\n     * Create an animation function to run once per frame. This will tween the visual bounding box from\r\n     * origin to target using the latest progress value.\r\n     */\n\n    var frame = function () {\n      // Convert the latest layoutProgress, which is a value from 0-1000, into a 0-1 progress\n      var p = layoutProgress.get() / progressTarget; // Tween the axis and update the visualElement with the latest values\n\n      tweenAxis(frameTarget, origin, target, p);\n      visualElement.setProjectionTargetAxis(axis, frameTarget.min, frameTarget.max, isRelative);\n    }; // Synchronously run a frame to ensure there's no flash of the uncorrected bounding box.\n\n\n    frame(); // Create a function to stop animation on this specific axis\n\n    var unsubscribeProgress = layoutProgress.onChange(frame);\n\n    this.stopAxisAnimation[axis] = function () {\n      _this.isAnimating[axis] = false;\n      layoutProgress.stop();\n      unsubscribeProgress();\n    };\n\n    this.currentAnimationTarget[axis] = target;\n    var layoutTransition = transition || visualElement.getDefaultTransition() || defaultLayoutTransition; // Start the animation on this axis\n\n    var animation = startAnimation(axis === \"x\" ? \"layoutX\" : \"layoutY\", layoutProgress, progressTarget, layoutTransition && getValueTransition(layoutTransition, \"layout\")).then(this.stopAxisAnimation[axis]);\n    return animation;\n  };\n\n  Animate.prototype.safeToRemove = function () {\n    var _a, _b;\n\n    (_b = (_a = this.props).safeToRemove) === null || _b === void 0 ? void 0 : _b.call(_a);\n  };\n\n  Animate.prototype.render = function () {\n    return null;\n  };\n\n  return Animate;\n}(React.Component);\n\nfunction AnimateLayoutContextProvider(props) {\n  var _a = __read(usePresence(), 2),\n      safeToRemove = _a[1];\n\n  return React.createElement(Animate, __assign({}, props, {\n    safeToRemove: safeToRemove\n  }));\n}\n\nfunction hasMoved(a, b) {\n  return !isZeroBox(a) && !isZeroBox(b) && (!axisIsEqual(a.x, b.x) || !axisIsEqual(a.y, b.y));\n}\n\nvar zeroAxis = {\n  min: 0,\n  max: 0\n};\n\nfunction isZeroBox(a) {\n  return axisIsEqual(a.x, zeroAxis) && axisIsEqual(a.y, zeroAxis);\n}\n\nfunction axisIsEqual(a, b) {\n  return a.min === b.min && a.max === b.max;\n}\n\nvar defaultLayoutTransition = {\n  duration: 0.45,\n  ease: [0.4, 0, 0.1, 1]\n};\n\nfunction isProvidedCorrectDataForRelativeSharedLayout(prevParent, originBox, targetBox) {\n  return prevParent || !prevParent && !(originBox || targetBox);\n}\n\nexport { AnimateLayoutContextProvider };","map":{"version":3,"names":["__extends","__rest","__assign","__read","React","eachAxis","startAnimation","getValueTransition","checkIfParentHasChanged","calcRelativeOffset","tweenAxis","VisibilityAction","usePresence","axisBox","addScaleCorrection","defaultScaleCorrectors","progressTarget","Animate","_super","_this","apply","arguments","frameTarget","currentAnimationTarget","isAnimating","x","y","stopAxisAnimation","undefined","isAnimatingTree","animate","target","origin","_a","originBox","targetBox","visibilityAction","shouldStackAnimate","onComplete","prevParent","config","_b","props","visualElement","layout","safeToRemove","isRelative","projectionParent","getProjectionParent","prevParentViewportBox","prevViewportBox","parentLayout","getLayoutState","isProvidedCorrectDataForRelativeSharedLayout","boxHasMoved","hasMoved","animations","axis","targetLength","max","min","projection","isTargetLocked","setVisibility","Show","animateAxis","setProjectionTargetAxis","syncRender","Promise","all","then","notifyLayoutAnimationComplete","prototype","componentDidMount","animateMotionValue","enableLayoutProjection","unsubLayoutReady","onLayoutUpdate","layoutSafeToRemove","componentWillUnmount","call","_c","_d","transition","axisIsEqual","layoutProgress","getProjectionAnimationProgress","clearListeners","set","frame","p","get","unsubscribeProgress","onChange","stop","layoutTransition","getDefaultTransition","defaultLayoutTransition","animation","render","Component","AnimateLayoutContextProvider","createElement","a","b","isZeroBox","zeroAxis","duration","ease"],"sources":["E:/Projects/project/project mangement dashbord/landing-pm-pange/node_modules/framer-motion/dist/es/motion/features/layout/Animate.js"],"sourcesContent":["import { __extends, __rest, __assign, __read } from 'tslib';\r\nimport * as React from 'react';\r\nimport { eachAxis } from '../../../utils/each-axis.js';\r\nimport { startAnimation, getValueTransition } from '../../../animation/utils/transitions.js';\r\nimport { checkIfParentHasChanged, calcRelativeOffset, tweenAxis } from './utils.js';\r\nimport { VisibilityAction } from '../../../components/AnimateSharedLayout/types.js';\r\nimport { usePresence } from '../../../components/AnimatePresence/use-presence.js';\r\nimport { axisBox } from '../../../utils/geometry/index.js';\r\nimport { addScaleCorrection } from '../../../render/dom/projection/scale-correction.js';\r\nimport { defaultScaleCorrectors } from '../../../render/dom/projection/default-scale-correctors.js';\r\n\r\nvar progressTarget = 1000;\r\nvar Animate = /** @class */ (function (_super) {\r\n    __extends(Animate, _super);\r\n    function Animate() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        /**\r\n         * A mutable object that tracks the target viewport box\r\n         * for the current animation frame.\r\n         */\r\n        _this.frameTarget = axisBox();\r\n        /**\r\n         * The current animation target, we use this to check whether to start\r\n         * a new animation or continue the existing one.\r\n         */\r\n        _this.currentAnimationTarget = axisBox();\r\n        /**\r\n         * Track whether we're animating this axis.\r\n         */\r\n        _this.isAnimating = {\r\n            x: false,\r\n            y: false,\r\n        };\r\n        _this.stopAxisAnimation = {\r\n            x: undefined,\r\n            y: undefined,\r\n        };\r\n        _this.isAnimatingTree = false;\r\n        _this.animate = function (target, origin, _a) {\r\n            if (_a === void 0) { _a = {}; }\r\n            var originBox = _a.originBox, targetBox = _a.targetBox, visibilityAction = _a.visibilityAction, shouldStackAnimate = _a.shouldStackAnimate, onComplete = _a.onComplete, prevParent = _a.prevParent, config = __rest(_a, [\"originBox\", \"targetBox\", \"visibilityAction\", \"shouldStackAnimate\", \"onComplete\", \"prevParent\"]);\r\n            var _b = _this.props, visualElement = _b.visualElement, layout = _b.layout;\r\n            /**\r\n             * Early return if we've been instructed not to animate this render.\r\n             */\r\n            if (shouldStackAnimate === false) {\r\n                _this.isAnimatingTree = false;\r\n                return _this.safeToRemove();\r\n            }\r\n            /**\r\n             * Prioritise tree animations\r\n             */\r\n            if (_this.isAnimatingTree && shouldStackAnimate !== true) {\r\n                return;\r\n            }\r\n            else if (shouldStackAnimate) {\r\n                _this.isAnimatingTree = true;\r\n            }\r\n            /**\r\n             * Allow the measured origin (prev bounding box) and target (actual layout) to be\r\n             * overridden by the provided config.\r\n             */\r\n            origin = originBox || origin;\r\n            target = targetBox || target;\r\n            /**\r\n             * If this element has a projecting parent, there's an opportunity to animate\r\n             * it relatively to that parent rather than relatively to the viewport. This\r\n             * allows us to add orchestrated animations.\r\n             */\r\n            var isRelative = false;\r\n            var projectionParent = visualElement.getProjectionParent();\r\n            if (projectionParent) {\r\n                var prevParentViewportBox = projectionParent.prevViewportBox;\r\n                var parentLayout = projectionParent.getLayoutState().layout;\r\n                /**\r\n                 * If we're being provided a previous parent VisualElement by AnimateSharedLayout\r\n                 */\r\n                if (prevParent) {\r\n                    /**\r\n                     * If we've been provided an explicit target box it means we're animating back\r\n                     * to this previous parent. So we can make a relative box by comparing to the previous\r\n                     * parent's layout\r\n                     */\r\n                    if (targetBox) {\r\n                        parentLayout = prevParent.getLayoutState().layout;\r\n                    }\r\n                    /**\r\n                     * Likewise if we've been provided an explicit origin box it means we're\r\n                     * animating out from a different element. So we should figure out where that was\r\n                     * on screen relative to the new parent element.\r\n                     */\r\n                    if (originBox &&\r\n                        !checkIfParentHasChanged(prevParent, projectionParent) &&\r\n                        prevParent.prevViewportBox) {\r\n                        prevParentViewportBox = prevParent.prevViewportBox;\r\n                    }\r\n                }\r\n                if (prevParentViewportBox &&\r\n                    isProvidedCorrectDataForRelativeSharedLayout(prevParent, originBox, targetBox)) {\r\n                    isRelative = true;\r\n                    origin = calcRelativeOffset(prevParentViewportBox, origin);\r\n                    target = calcRelativeOffset(parentLayout, target);\r\n                }\r\n            }\r\n            var boxHasMoved = hasMoved(origin, target);\r\n            var animations = eachAxis(function (axis) {\r\n                /**\r\n                 * If layout is set to \"position\", we can resize the origin box based on the target\r\n                 * box and only animate its position.\r\n                 */\r\n                if (layout === \"position\") {\r\n                    var targetLength = target[axis].max - target[axis].min;\r\n                    origin[axis].max = origin[axis].min + targetLength;\r\n                }\r\n                if (visualElement.projection.isTargetLocked) {\r\n                    return;\r\n                }\r\n                else if (visibilityAction !== undefined) {\r\n                    visualElement.setVisibility(visibilityAction === VisibilityAction.Show);\r\n                }\r\n                else if (boxHasMoved) {\r\n                    // If the box has moved, animate between it's current visual state and its\r\n                    // final state\r\n                    return _this.animateAxis(axis, target[axis], origin[axis], __assign(__assign({}, config), { isRelative: isRelative }));\r\n                }\r\n                else {\r\n                    // If the box has remained in the same place, immediately set the axis target\r\n                    // to the final desired state\r\n                    return visualElement.setProjectionTargetAxis(axis, target[axis].min, target[axis].max, isRelative);\r\n                }\r\n            });\r\n            // Force a render to ensure there's no flash of uncorrected bounding box.\r\n            visualElement.syncRender();\r\n            /**\r\n             * If this visualElement isn't present (ie it's been removed from the tree by the user but\r\n             * kept in by the tree by AnimatePresence) then call safeToRemove when all axis animations\r\n             * have successfully finished.\r\n             */\r\n            return Promise.all(animations).then(function () {\r\n                _this.isAnimatingTree = false;\r\n                onComplete && onComplete();\r\n                visualElement.notifyLayoutAnimationComplete();\r\n            });\r\n        };\r\n        return _this;\r\n    }\r\n    Animate.prototype.componentDidMount = function () {\r\n        var _this = this;\r\n        var visualElement = this.props.visualElement;\r\n        visualElement.animateMotionValue = startAnimation;\r\n        visualElement.enableLayoutProjection();\r\n        this.unsubLayoutReady = visualElement.onLayoutUpdate(this.animate);\r\n        visualElement.layoutSafeToRemove = function () { return _this.safeToRemove(); };\r\n        addScaleCorrection(defaultScaleCorrectors);\r\n    };\r\n    Animate.prototype.componentWillUnmount = function () {\r\n        var _this = this;\r\n        this.unsubLayoutReady();\r\n        eachAxis(function (axis) { var _a, _b; return (_b = (_a = _this.stopAxisAnimation)[axis]) === null || _b === void 0 ? void 0 : _b.call(_a); });\r\n    };\r\n    /**\r\n     * TODO: This manually performs animations on the visualElement's layout progress\r\n     * values. It'd be preferable to amend the startLayoutAxisAnimation\r\n     * API to accept more custom animations like this.\r\n     */\r\n    Animate.prototype.animateAxis = function (axis, target, origin, _a) {\r\n        var _this = this;\r\n        var _b, _c;\r\n        var _d = _a === void 0 ? {} : _a, transition = _d.transition, isRelative = _d.isRelative;\r\n        /**\r\n         * If we're not animating to a new target, don't run this animation\r\n         */\r\n        if (this.isAnimating[axis] &&\r\n            axisIsEqual(target, this.currentAnimationTarget[axis])) {\r\n            return;\r\n        }\r\n        (_c = (_b = this.stopAxisAnimation)[axis]) === null || _c === void 0 ? void 0 : _c.call(_b);\r\n        this.isAnimating[axis] = true;\r\n        var visualElement = this.props.visualElement;\r\n        var frameTarget = this.frameTarget[axis];\r\n        var layoutProgress = visualElement.getProjectionAnimationProgress()[axis];\r\n        /**\r\n         * Set layout progress back to 0. We set it twice to hard-reset any velocity that might\r\n         * be re-incoporated into a subsequent spring animation.\r\n         */\r\n        layoutProgress.clearListeners();\r\n        layoutProgress.set(0);\r\n        layoutProgress.set(0);\r\n        /**\r\n         * Create an animation function to run once per frame. This will tween the visual bounding box from\r\n         * origin to target using the latest progress value.\r\n         */\r\n        var frame = function () {\r\n            // Convert the latest layoutProgress, which is a value from 0-1000, into a 0-1 progress\r\n            var p = layoutProgress.get() / progressTarget;\r\n            // Tween the axis and update the visualElement with the latest values\r\n            tweenAxis(frameTarget, origin, target, p);\r\n            visualElement.setProjectionTargetAxis(axis, frameTarget.min, frameTarget.max, isRelative);\r\n        };\r\n        // Synchronously run a frame to ensure there's no flash of the uncorrected bounding box.\r\n        frame();\r\n        // Create a function to stop animation on this specific axis\r\n        var unsubscribeProgress = layoutProgress.onChange(frame);\r\n        this.stopAxisAnimation[axis] = function () {\r\n            _this.isAnimating[axis] = false;\r\n            layoutProgress.stop();\r\n            unsubscribeProgress();\r\n        };\r\n        this.currentAnimationTarget[axis] = target;\r\n        var layoutTransition = transition ||\r\n            visualElement.getDefaultTransition() ||\r\n            defaultLayoutTransition;\r\n        // Start the animation on this axis\r\n        var animation = startAnimation(axis === \"x\" ? \"layoutX\" : \"layoutY\", layoutProgress, progressTarget, layoutTransition && getValueTransition(layoutTransition, \"layout\")).then(this.stopAxisAnimation[axis]);\r\n        return animation;\r\n    };\r\n    Animate.prototype.safeToRemove = function () {\r\n        var _a, _b;\r\n        (_b = (_a = this.props).safeToRemove) === null || _b === void 0 ? void 0 : _b.call(_a);\r\n    };\r\n    Animate.prototype.render = function () {\r\n        return null;\r\n    };\r\n    return Animate;\r\n}(React.Component));\r\nfunction AnimateLayoutContextProvider(props) {\r\n    var _a = __read(usePresence(), 2), safeToRemove = _a[1];\r\n    return React.createElement(Animate, __assign({}, props, { safeToRemove: safeToRemove }));\r\n}\r\nfunction hasMoved(a, b) {\r\n    return (!isZeroBox(a) &&\r\n        !isZeroBox(b) &&\r\n        (!axisIsEqual(a.x, b.x) || !axisIsEqual(a.y, b.y)));\r\n}\r\nvar zeroAxis = { min: 0, max: 0 };\r\nfunction isZeroBox(a) {\r\n    return axisIsEqual(a.x, zeroAxis) && axisIsEqual(a.y, zeroAxis);\r\n}\r\nfunction axisIsEqual(a, b) {\r\n    return a.min === b.min && a.max === b.max;\r\n}\r\nvar defaultLayoutTransition = {\r\n    duration: 0.45,\r\n    ease: [0.4, 0, 0.1, 1],\r\n};\r\nfunction isProvidedCorrectDataForRelativeSharedLayout(prevParent, originBox, targetBox) {\r\n    return prevParent || (!prevParent && !(originBox || targetBox));\r\n}\r\n\r\nexport { AnimateLayoutContextProvider };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}