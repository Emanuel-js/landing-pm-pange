{"ast":null,"code":"import { zeroLayout } from '../../utils/state.js';\n/**\n * Build a transform style that takes a calculated delta between the element's current\n * space on screen and projects it into the desired space.\n */\n\nfunction buildLayoutProjectionTransform(_a, treeScale, latestTransform) {\n  var x = _a.x,\n      y = _a.y;\n  /**\n   * The translations we use to calculate are always relative to the viewport coordinate space.\n   * But when we apply scales, we also scale the coordinate space of an element and its children.\n   * For instance if we have a treeScale (the culmination of all parent scales) of 0.5 and we need\n   * to move an element 100 pixels, we actually need to move it 200 in within that scaled space.\n   */\n\n  var xTranslate = x.translate / treeScale.x;\n  var yTranslate = y.translate / treeScale.y;\n  var transform = \"translate3d(\" + xTranslate + \"px, \" + yTranslate + \"px, 0) \";\n\n  if (latestTransform) {\n    var rotate = latestTransform.rotate,\n        rotateX = latestTransform.rotateX,\n        rotateY = latestTransform.rotateY;\n    if (rotate) transform += \"rotate(\" + rotate + \") \";\n    if (rotateX) transform += \"rotateX(\" + rotateX + \") \";\n    if (rotateY) transform += \"rotateY(\" + rotateY + \") \";\n  }\n\n  transform += \"scale(\" + x.scale + \", \" + y.scale + \")\";\n  return !latestTransform && transform === identityProjection ? \"\" : transform;\n}\n/**\n * Take the calculated delta origin and apply it as a transform string.\n */\n\n\nfunction buildLayoutProjectionTransformOrigin(_a) {\n  var deltaFinal = _a.deltaFinal;\n  return deltaFinal.x.origin * 100 + \"% \" + deltaFinal.y.origin * 100 + \"% 0\";\n}\n\nvar identityProjection = buildLayoutProjectionTransform(zeroLayout.delta, zeroLayout.treeScale, {\n  x: 1,\n  y: 1\n});\nexport { buildLayoutProjectionTransform, buildLayoutProjectionTransformOrigin, identityProjection };","map":{"version":3,"names":["zeroLayout","buildLayoutProjectionTransform","_a","treeScale","latestTransform","x","y","xTranslate","translate","yTranslate","transform","rotate","rotateX","rotateY","scale","identityProjection","buildLayoutProjectionTransformOrigin","deltaFinal","origin","delta"],"sources":["C:/Users/User/Desktop/ArifPAy/other file/me/node_modules/framer-motion/dist/es/render/html/utils/build-projection-transform.js"],"sourcesContent":["import { zeroLayout } from '../../utils/state.js';\n\n/**\n * Build a transform style that takes a calculated delta between the element's current\n * space on screen and projects it into the desired space.\n */\nfunction buildLayoutProjectionTransform(_a, treeScale, latestTransform) {\n    var x = _a.x, y = _a.y;\n    /**\n     * The translations we use to calculate are always relative to the viewport coordinate space.\n     * But when we apply scales, we also scale the coordinate space of an element and its children.\n     * For instance if we have a treeScale (the culmination of all parent scales) of 0.5 and we need\n     * to move an element 100 pixels, we actually need to move it 200 in within that scaled space.\n     */\n    var xTranslate = x.translate / treeScale.x;\n    var yTranslate = y.translate / treeScale.y;\n    var transform = \"translate3d(\" + xTranslate + \"px, \" + yTranslate + \"px, 0) \";\n    if (latestTransform) {\n        var rotate = latestTransform.rotate, rotateX = latestTransform.rotateX, rotateY = latestTransform.rotateY;\n        if (rotate)\n            transform += \"rotate(\" + rotate + \") \";\n        if (rotateX)\n            transform += \"rotateX(\" + rotateX + \") \";\n        if (rotateY)\n            transform += \"rotateY(\" + rotateY + \") \";\n    }\n    transform += \"scale(\" + x.scale + \", \" + y.scale + \")\";\n    return !latestTransform && transform === identityProjection ? \"\" : transform;\n}\n/**\n * Take the calculated delta origin and apply it as a transform string.\n */\nfunction buildLayoutProjectionTransformOrigin(_a) {\n    var deltaFinal = _a.deltaFinal;\n    return deltaFinal.x.origin * 100 + \"% \" + deltaFinal.y.origin * 100 + \"% 0\";\n}\nvar identityProjection = buildLayoutProjectionTransform(zeroLayout.delta, zeroLayout.treeScale, { x: 1, y: 1 });\n\nexport { buildLayoutProjectionTransform, buildLayoutProjectionTransformOrigin, identityProjection };\n"],"mappings":"AAAA,SAASA,UAAT,QAA2B,sBAA3B;AAEA;AACA;AACA;AACA;;AACA,SAASC,8BAAT,CAAwCC,EAAxC,EAA4CC,SAA5C,EAAuDC,eAAvD,EAAwE;EACpE,IAAIC,CAAC,GAAGH,EAAE,CAACG,CAAX;EAAA,IAAcC,CAAC,GAAGJ,EAAE,CAACI,CAArB;EACA;AACJ;AACA;AACA;AACA;AACA;;EACI,IAAIC,UAAU,GAAGF,CAAC,CAACG,SAAF,GAAcL,SAAS,CAACE,CAAzC;EACA,IAAII,UAAU,GAAGH,CAAC,CAACE,SAAF,GAAcL,SAAS,CAACG,CAAzC;EACA,IAAII,SAAS,GAAG,iBAAiBH,UAAjB,GAA8B,MAA9B,GAAuCE,UAAvC,GAAoD,SAApE;;EACA,IAAIL,eAAJ,EAAqB;IACjB,IAAIO,MAAM,GAAGP,eAAe,CAACO,MAA7B;IAAA,IAAqCC,OAAO,GAAGR,eAAe,CAACQ,OAA/D;IAAA,IAAwEC,OAAO,GAAGT,eAAe,CAACS,OAAlG;IACA,IAAIF,MAAJ,EACID,SAAS,IAAI,YAAYC,MAAZ,GAAqB,IAAlC;IACJ,IAAIC,OAAJ,EACIF,SAAS,IAAI,aAAaE,OAAb,GAAuB,IAApC;IACJ,IAAIC,OAAJ,EACIH,SAAS,IAAI,aAAaG,OAAb,GAAuB,IAApC;EACP;;EACDH,SAAS,IAAI,WAAWL,CAAC,CAACS,KAAb,GAAqB,IAArB,GAA4BR,CAAC,CAACQ,KAA9B,GAAsC,GAAnD;EACA,OAAO,CAACV,eAAD,IAAoBM,SAAS,KAAKK,kBAAlC,GAAuD,EAAvD,GAA4DL,SAAnE;AACH;AACD;AACA;AACA;;;AACA,SAASM,oCAAT,CAA8Cd,EAA9C,EAAkD;EAC9C,IAAIe,UAAU,GAAGf,EAAE,CAACe,UAApB;EACA,OAAOA,UAAU,CAACZ,CAAX,CAAaa,MAAb,GAAsB,GAAtB,GAA4B,IAA5B,GAAmCD,UAAU,CAACX,CAAX,CAAaY,MAAb,GAAsB,GAAzD,GAA+D,KAAtE;AACH;;AACD,IAAIH,kBAAkB,GAAGd,8BAA8B,CAACD,UAAU,CAACmB,KAAZ,EAAmBnB,UAAU,CAACG,SAA9B,EAAyC;EAAEE,CAAC,EAAE,CAAL;EAAQC,CAAC,EAAE;AAAX,CAAzC,CAAvD;AAEA,SAASL,8BAAT,EAAyCe,oCAAzC,EAA+ED,kBAA/E"},"metadata":{},"sourceType":"module"}